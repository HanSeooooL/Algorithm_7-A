알고리즘 설계 구현 보고서: <가짜 동전 찾기>

<문제 정의>
문제이름: 가짜 동전 찾기
문제설명: 주어진 동전 중 무게가 무거운 가짜 동전을 양팔 저울로 찾기

<해결 아이디어>
1) 한준규
동전을 반으로 나눠 저울에 한쪽씩 올린 후 무게가 무거운 쪽을 선택. 그 후 무거운 쪽 그룹을 다시 반으로 나눠 비교를 반복.
(2) : 김민우
동전을 2개씩 짝을 지어 n/2 짝을 각각 저울에 달아 가짜 동전을 찾는다.

<알고리즘>
명칭: 가짜 동전 찾기 (findFakeCoin)
입력: 무게가 다른 가짜 동전 하나가 섞인 동전들
출력: 무게가 다른 가짜 동전
처리순서:
1. 동전 개수를 입력 받는다.
2. n개의 동전 무게를 입력받아 배열에 저장한다.
3. 동전을 반으로 나눠 무게를 비교한다.
4. 왼쪽이 무거우면 왼쪽 저울 탐색, 오른쪽이 무거우면 오른쪽 저울 탐색
5. 가짜 동전이 없으면 1 리턴

<코드 설계>
1. 자료 구조 정의
-입력받은 동전 개수: int n(정수)
-가짜 동전: int fake(정수), 
-동전을 저장하는 메모리: int*coins(정수형 포인터)
-저울 무게: int sumLeft, sumRight(정수)
-양쪽 저울 무게 중간값: int mid(정수)

2. 함수정의
-기능: 동전 배열과 왼쪽, 오른쪽 값을 입력받아 가짜 동전 출력
-프로토타입: int findFakeCoin(int left, int right, int coins[])


3. 테스트 케이스 설계
```
테스트1 //동전 받는 개수 작동
int main() {
	int n;
	int fake;
	
	printf("동전의 개수를 입력하세요: ");
	scanf_s("%d", &n);
	int* coins = (int*)malloc(sizeof(int) * n); // 동적 메모리 할당
	
	for (int i = 0; i < n; i++) {
		printf("%d번 동전의 무게를 입력하세요: ", i + 1);
		scanf_s("%d", &coins[i]);
	}

테스트2 //동전 10개일 때 가정하고 찾기
//main함수에 아래 코드 추가
int coins10[10] = { 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };
fake = findFakeCoin(0, 9, coins10);
```
